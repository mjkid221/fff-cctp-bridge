diff --git a/index.cjs b/index.cjs
index 280b3279f059996534ac2954a47f0daf0f0f3e4e..a6d23af44b3575c6795cbaf7230c0f04f40d7fc7 100644
--- a/index.cjs
+++ b/index.cjs
@@ -4728,9 +4728,21 @@ async function fetchUsdcFastBurnFee(sourceDomain, destinationDomain, isTestnet)
         throw new Error(`No fast tier (finalityThreshold: ${FAST_TIER_FINALITY_THRESHOLD.toString()}) available in API response`);
     }
     // Convert minimumFee to bigint
+    // Handle decimal fee values (e.g., "1.3") by parsing as float and rounding
     let minimumFee;
     try {
-        minimumFee = BigInt(fastTier.minimumFee);
+        const feeValue = String(fastTier.minimumFee);
+        // Check if it's a decimal string
+        if (feeValue.includes('.')) {
+            // Parse as float and round to nearest integer
+            const feeAsNumber = parseFloat(feeValue);
+            if (isNaN(feeAsNumber)) {
+                throw new Error('NaN');
+            }
+            minimumFee = BigInt(Math.round(feeAsNumber));
+        } else {
+            minimumFee = BigInt(fastTier.minimumFee);
+        }
     }
     catch {
         throw new Error(`Invalid minimumFee value: cannot convert "${String(fastTier.minimumFee)}" to bigint`);
diff --git a/index.mjs b/index.mjs
index deee48425808a50613fc8aa7abab6c8f2974a0fb..430e0271c67211a64a6d938d42871aa1a2dbb551 100644
--- a/index.mjs
+++ b/index.mjs
@@ -4722,9 +4722,21 @@ async function fetchUsdcFastBurnFee(sourceDomain, destinationDomain, isTestnet)
         throw new Error(`No fast tier (finalityThreshold: ${FAST_TIER_FINALITY_THRESHOLD.toString()}) available in API response`);
     }
     // Convert minimumFee to bigint
+    // Handle decimal fee values (e.g., "1.3") by parsing as float and rounding
     let minimumFee;
     try {
-        minimumFee = BigInt(fastTier.minimumFee);
+        const feeValue = String(fastTier.minimumFee);
+        // Check if it's a decimal string
+        if (feeValue.includes('.')) {
+            // Parse as float and round to nearest integer
+            const feeAsNumber = parseFloat(feeValue);
+            if (isNaN(feeAsNumber)) {
+                throw new Error('NaN');
+            }
+            minimumFee = BigInt(Math.round(feeAsNumber));
+        } else {
+            minimumFee = BigInt(fastTier.minimumFee);
+        }
     }
     catch {
         throw new Error(`Invalid minimumFee value: cannot convert "${String(fastTier.minimumFee)}" to bigint`);
